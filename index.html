<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Word Search â€” 10-Level Challenge</title>
<link rel="icon" href="data:," />
<style>
  :root{
    --bg1:linear-gradient(135deg,#081426 0%,#0f2040 100%);
    --card:#071428;
    --accent:#7b61ff;
    --accent-2:#22d3ee;
    --text:#e6eef8;
    --muted:#9fb0c8;
    --found:#19a974;
    --select:#ffb86b;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;color:var(--text);background:var(--bg1)}
  .wrap{max-width:1100px;margin:28px auto;padding:20px}
  header{display:flex;align-items:center;justify-content:space-between;gap:16px;margin-bottom:18px}
  header h1{margin:0;font-size:20px;letter-spacing:0.6px}
  .controls{display:flex;gap:10px;align-items:center}
  button, select{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--text);padding:8px 12px;border-radius:10px;cursor:pointer;font-weight:600}
  button.primary{background:linear-gradient(90deg,var(--accent),var(--accent-2));border:none;color:#041024}
  .layout{display:grid;grid-template-columns: 1fr 320px;gap:18px}
  @media (max-width:980px){.layout{grid-template-columns:1fr}}
  .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:14px;padding:16px;box-shadow: 0 6px 30px rgba(5,10,20,0.6);border:1px solid rgba(255,255,255,0.03)}
  .meta{display:flex;gap:12px;align-items:center;margin-bottom:12px;flex-wrap:wrap}
  .chip{background:rgba(255,255,255,0.03);padding:8px 10px;border-radius:10px;font-weight:700;color:var(--muted);display:inline-flex;gap:8px;align-items:center}
  .chip .num{color:var(--text);font-weight:800;margin-left:4px}
  .gridWrap{display:flex;justify-content:center;align-items:center}
  #grid{display:grid;gap:4px;background:linear-gradient(180deg,#061022,#071428);padding:10px;border-radius:12px;touch-action:none}
  .cell{
    width:40px;height:40px;display:flex;align-items:center;justify-content:center;
    background:linear-gradient(180deg,#0c2a46,#062033);border-radius:6px;font-weight:800;font-size:18px;
    color:var(--text);user-select:none;cursor:pointer;box-shadow: 0 2px 0 rgba(0,0,0,0.5) inset;
    transition:transform .08s,box-shadow .12s,background .12s;
  }
  .cell:hover{transform:translateY(-3px)}
  .cell.select{background:linear-gradient(90deg,var(--select),#ff9a6a);color:#041024;box-shadow:0 6px 18px rgba(255,186,107,0.12)}
  .cell.found{background:linear-gradient(90deg,var(--found),#44e29c);color:#012014;box-shadow:0 6px 18px rgba(27,183,123,0.12)}
  .wordList{padding-left:12px}
  .wordList ul{list-style:none;padding:0;margin:0;display:flex;flex-direction:column;gap:8px}
  .wordItem{padding:8px 10px;border-radius:8px;background:rgba(255,255,255,0.02);display:flex;justify-content:space-between;align-items:center;color:var(--text)}
  .wordItem.found{background:linear-gradient(90deg,#183a2d,#13523f);text-decoration:line-through;color:#b9f0d7}
  .footer{margin-top:12px;display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap}
  .progress{height:10px;background:rgba(255,255,255,0.04);border-radius:6px;overflow:hidden;flex:1}
  .progress > i{display:block;height:100%;background:linear-gradient(90deg,var(--accent),var(--accent-2));width:0%}
  .hint{color:var(--muted);font-size:13px}
  .center{display:flex;gap:10px;align-items:center}
  .big{font-size:20px;font-weight:800}
  .small{font-size:13px;color:var(--muted)}
  .actions{display:flex;gap:8px}
  .hintBtn{background:rgba(255,255,255,0.02);border:1px dashed rgba(255,255,255,0.04);padding:6px 8px;border-radius:10px}
  /* responsive for smaller grids */
  @media (max-width:520px){
    .cell{width:32px;height:32px;font-size:15px}
  }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>ðŸ”Ž Word Search â€” 10-Level Challenge</h1>
      <div class="controls">
        <div class="chip">Level: <span id="levelNum" class="num">1</span></div>
        <div class="chip">Time: <span id="timer" class="num">--</span>s</div>
        <div class="chip">Found: <span id="foundCount" class="num">0</span>/<span id="totalWords" class="num">0</span></div>
        <button id="btnRestart">Restart Level</button>
        <button id="btnNext" class="primary" title="Next level (unlocks after you find all words)">Next Level</button>
      </div>
    </header>

    <div class="layout">
      <div class="card">
        <div class="meta">
          <div class="chip">Grid: <span id="gridSize" class="num">8Ã—8</span></div>
          <div class="chip">Score: <span id="score" class="num">0</span></div>
          <div class="chip">Hints: <span id="hints" class="num">3</span></div>
        </div>

        <div class="gridWrap">
          <div id="grid" role="grid" style="touch-action: none"></div>
        </div>

        <div class="footer" style="margin-top:12px;">
          <div class="center">
            <div style="width:220px">
              <div class="small">Progress</div>
              <div class="progress" aria-hidden><i id="progressBar"></i></div>
            </div>
            <div class="hint small" id="message">Select words by dragging (mouse or touch). Diagonals allowed.</div>
          </div>

          <div class="actions">
            <button id="btnHint" class="hintBtn">Reveal Hint (-10s)</button>
            <select id="levelSelect"></select>
          </div>
        </div>
      </div>

      <aside class="card">
        <h3 style="margin-top:0;margin-bottom:8px">Words to find</h3>
        <div class="wordList">
          <ul id="wordList"></ul>
        </div>

        <div style="margin-top:12px" class="small">
          <strong>Controls:</strong> Drag to select words â€¢ <strong>Hint</strong> reveals starting letter (time penalty).<br>
          Auto-advances when you find all words. Harder levels = larger grid & more words.
        </div>
      </aside>
    </div>
  </div>

<script>
/* ===== Word Search â€” 10-level game =====
   - Drag to select words (mouse & touch supported)
   - Words placed in 8 directions; algorithm retries until fit
   - Timer per level, scoring, hints, and nice styling
*/

const LEVELS = [
  {size:8, words:["CAT","DOG","SUN","MOON"]},
  {size:9, words:["APPLE","HOUSE","BOOK","TREE","CAR"]},
  {size:10, words:["PYTHON","JAVASCRIPT","CODING","DEBUG","ARRAY"]},
  {size:11, words:["COMPUTER","NETWORK","SOFTWARE","HARDWARE","MOUSE"]},
  {size:12, words:["ALGORITHM","FUNCTION","VARIABLE","DATABASE","BINARY","STORAGE"]},
  {size:13, words:["ENCRYPTION","SECURITY","INTERNET","PROTOCOL","FIREWALL","ROUTER"]},
  {size:14, words:["DEVELOPER","FRAMEWORK","PERFORMANCE","OPTIMIZATION","COMPILER","INTERFACE","ASYNC"]},
  {size:15, words:["MICROSERVICE","CONCURRENCY","PARALLELISM","VIRTUALIZATION","SCALABILITY","CONTAINER","CLOUD"]},
  {size:16, words:["ARCHITECTURE","AUTHENTICATION","ORCHESTRATION","OBSERVABILITY","LOADBALANCER","AUTOMATION"]},
  {size:17, words:["DISTRIBUTED","FAULTTOLERANT","RELIABILITY","THREADSAFE","PARALLELDATA","HIGHAVAILABILITY"]}
];

let state = {
  levelIndex: 0,
  size: 8,
  words: [],
  grid: [],
  cellElems: [],
  foundSet: new Set(),
  timer: 0,
  timerInterval: null,
  dragging: false,
  startCell: null,
  currCell: null,
  score: 0,
  hints: 3
};

const el = {
  grid: document.getElementById('grid'),
  wordList: document.getElementById('wordList'),
  levelNum: document.getElementById('levelNum'),
  gridSize: document.getElementById('gridSize'),
  timer: document.getElementById('timer'),
  foundCount: document.getElementById('foundCount'),
  totalWords: document.getElementById('totalWords'),
  progressBar: document.getElementById('progressBar'),
  message: document.getElementById('message'),
  score: document.getElementById('score'),
  hints: document.getElementById('hints'),
  levelSelect: document.getElementById('levelSelect'),
  btnNext: document.getElementById('btnNext'),
  btnRestart: document.getElementById('btnRestart'),
  btnHint: document.getElementById('btnHint'),
  btnLevelSelect: null
};

/* --- Utility --- */
const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
const rand = (a,b)=> Math.floor(a + Math.random()*(b-a+1));
const shuffle = arr => arr.sort(()=>Math.random()-0.5);
const clamp = (v,a,b) => Math.max(a,Math.min(b,v));

/* --- Directions for placement (dy, dx) */
const DIRS = [
  {dy:-1,dx:0}, // up
  {dy:1,dx:0},  // down
  {dy:0,dx:-1}, // left
  {dy:0,dx:1},  // right
  {dy:-1,dx:-1},// up-left
  {dy:-1,dx:1}, // up-right
  {dy:1,dx:-1}, // down-left
  {dy:1,dx:1}   // down-right
];

/* --- Setup level select dropdown --- */
function buildLevelSelect(){
  LEVELS.forEach((lv,i)=>{
    const opt = document.createElement('option');
    opt.value = i;
    opt.textContent = `Level ${i+1} â€” ${lv.size}Ã—${lv.size} (${lv.words.length} words)`;
    el.levelSelect.appendChild(opt);
  });
  el.levelSelect.value = 0;
  el.levelSelect.addEventListener('change', ()=> {
    loadLevel(parseInt(el.levelSelect.value,10));
  });
}

/* --- Create an empty grid --- */
function makeEmptyGrid(n){
  const g = new Array(n);
  for(let r=0;r<n;r++){
    g[r] = new Array(n).fill(null);
  }
  return g;
}

/* --- Try placing all words; returns grid or null if fail --- */
function placeWords(size, words){
  // We'll attempt several full retries to avoid impossible placements
  const MAX_RESTARTS = 12;
  for(let attempt=0; attempt<MAX_RESTARTS; attempt++){
    const grid = makeEmptyGrid(size);
    let ok = true;
    // randomize order (place longer words first helps)
    const order = [...words].sort((a,b)=>b.length-a.length);
    for(const w of order){
      if(!placeSingleWord(grid, size, w)){
        ok = false;
        break;
      }
    }
    if(ok) return grid;
  }
  return null;
}

/* --- Place one word randomly on grid; respects crossings --- */
function placeSingleWord(grid, size, word){
  const len = word.length;
  const tries = 220;
  for(let t=0;t<tries;t++){
    const dir = DIRS[rand(0, DIRS.length-1)];
    // compute range for start so end stays inside
    const maxRowStart = dir.dy === 1 ? size - len : dir.dy === -1 ? len - 1 : size - 1;
    const minRowStart = dir.dy === -1 ? len - 1 : 0;
    const maxColStart = dir.dx === 1 ? size - len : dir.dx === -1 ? len - 1 : size - 1;
    const minColStart = dir.dx === -1 ? len - 1 : 0;
    const r0 = rand(minRowStart, maxRowStart);
    const c0 = rand(minColStart, maxColStart);

    // check fits and conflicts
    let r = r0, c = c0;
    let fits = true;
    for(let k=0;k<len;k++){
      const ch = grid[r][c];
      if(ch !== null && ch !== word[k]) { fits = false; break; }
      r += dir.dy; c += dir.dx;
    }
    if(!fits) continue;

    // place
    r = r0; c = c0;
    for(let k=0;k<len;k++){
      grid[r][c] = word[k];
      r += dir.dy; c += dir.dx;
    }
    return true;
  }
  return false;
}

/* --- Fill blanks with random letters --- */
function fillRandom(grid){
  for(let r=0;r<grid.length;r++){
    for(let c=0;c<grid.length;c++){
      if(!grid[r][c]) grid[r][c] = letters[rand(0,letters.length-1)];
    }
  }
}

/* --- Render grid DOM --- */
function renderGrid(grid){
  el.grid.innerHTML = '';
  const n = grid.length;
  el.grid.style.gridTemplateColumns = `repeat(${n}, auto)`;
  state.cellElems = Array.from({length:n}, ()=>new Array(n));
  for(let r=0;r<n;r++){
    for(let c=0;c<n;c++){
      const d = document.createElement('div');
      d.className = 'cell';
      d.textContent = grid[r][c];
      d.dataset.r = r; d.dataset.c = c;
      d.setAttribute('role','gridcell');
      d.setAttribute('aria-label', `row ${r+1} col ${c+1} letter ${grid[r][c]}`);
      el.grid.appendChild(d);
      state.cellElems[r][c] = d;
    }
  }
}

/* --- Render word list --- */
function renderWordList(words){
  el.wordList.innerHTML = '';
  for(const w of words){
    const li = document.createElement('li');
    li.className = 'wordItem';
    li.dataset.word = w;
    li.innerHTML = `<span>${w}</span><small style="opacity:.65">${w.length}</small>`;
    el.wordList.appendChild(li);
  }
  el.totalWords.textContent = words.length;
}

/* --- Utility: get path between two cells if straight line --- */
function getPath(r1,c1,r2,c2){
  const dr = r2 - r1;
  const dc = c2 - c1;
  const stepR = dr === 0 ? 0 : (dr > 0 ? 1 : -1);
  const stepC = dc === 0 ? 0 : (dc > 0 ? 1 : -1);
  // validate straight or diagonal
  if(!(dr === 0 || dc === 0 || Math.abs(dr) === Math.abs(dc))) return null;
  const len = Math.max(Math.abs(dr), Math.abs(dc)) + 1;
  const path = [];
  let rr = r1, cc = c1;
  for(let i=0;i<len;i++){
    path.push({r:rr,c:cc});
    rr += stepR; cc += stepC;
  }
  return path;
}

/* --- Convert path to word --- */
function pathToWord(path){
  return path.map(p => state.grid[p.r][p.c]).join('');
}

/* --- Visual helpers --- */
function clearSelection(){
  document.querySelectorAll('.cell.select').forEach(e=>e.classList.remove('select'));
}
function markFoundCells(path){
  for(const p of path){
    state.cellElems[p.r][p.c].classList.add('found');
  }
}

/* --- Game logic: when selection finalizes --- */
function finalizeSelection(path){
  if(!path || path.length < 2) return false;
  const wordF = pathToWord(path);
  const wordR = wordF.split('').reverse().join('');

  const candidate = state.words.find(w => (w === wordF || w === wordR));
  if(candidate && !state.foundSet.has(candidate)){
    // mark as found
    state.foundSet.add(candidate);
    // highlight in wordlist
    const li = [...el.wordList.children].find(x => x.dataset.word === candidate);
    if(li) li.classList.add('found');
    // mark cells
    markFoundCells(path);
    updateFoundCount();
    // scoring: length*10 + time bonus
    state.score += candidate.length * 10 + Math.max(0, Math.floor(state.timer / 5));
    el.score.textContent = state.score;
    el.message.textContent = `Nice! Found "${candidate}"`;
    setTimeout(()=>el.message.textContent = `Keep going â€” ${state.words.length - state.foundSet.size} left`, 1200);
    // Progress bar
    updateProgress();
    // check level completion
    if(state.foundSet.size >= state.words.length){
      levelComplete();
    }
    return true;
  } else {
    // wrong selection - flash
    el.message.textContent = 'Nope â€” try another direction';
    const highlight = [];
    for(const p of path){
      const e = state.cellElems[p.r][p.c];
      e.classList.add('select');
      highlight.push(e);
    }
    setTimeout(()=>highlight.forEach(e=>e.classList.remove('select')), 350);
    return false;
  }
}

/* --- Level complete handling --- */
function levelComplete(){
  stopTimer();
  el.message.textContent = 'Level complete! Unlocking next level...';
  el.btnNext.disabled = false;
  // small delay then auto advance
  setTimeout(()=> {
    if(state.levelIndex < LEVELS.length - 1){
      loadLevel(state.levelIndex + 1);
    } else {
      el.message.textContent = 'You finished all levels â€” awesome!';
    }
  }, 1000);
}

/* --- Timer --- */
function startTimer(seconds){
  stopTimer();
  state.timer = seconds;
  el.timer.textContent = state.timer;
  state.timerInterval = setInterval(()=>{
    state.timer--;
    el.timer.textContent = state.timer;
    if(state.timer <= 0){
      stopTimer();
      el.message.textContent = 'Time up! Restarting level...';
      setTimeout(()=> loadLevel(state.levelIndex), 1000);
    }
  }, 1000);
}
function stopTimer(){
  if(state.timerInterval) { clearInterval(state.timerInterval); state.timerInterval = null; }
}

/* --- Update found counter & progress --- */
function updateFoundCount(){
  el.foundCount.textContent = state.foundSet.size;
}
function updateProgress(){
  const pct = Math.round((state.foundSet.size / state.words.length) * 100);
  el.progressBar.style.width = pct + '%';
}

/* --- Hint: reveal first letter position of a remaining word --- */
function useHint(){
  if(state.hints <= 0){ el.message.textContent = "No hints left."; return; }
  const remaining = state.words.filter(w => !state.foundSet.has(w));
  if(!remaining.length) return;
  const pick = remaining[0];
  // find pick in grid by scanning possible paths (forward/back)
  for(let r=0;r<state.size;r++){
    for(let c=0;c<state.size;c++){
      if(state.grid[r][c] !== pick[0]) continue;
      // check each dir if complete match
      for(const dir of DIRS){
        let rr=r, cc=c, k=0, ok=true;
        while(k < pick.length){
          if(rr < 0 || rr >= state.size || cc < 0 || cc >= state.size){ ok=false; break; }
          if(state.grid[rr][cc] !== pick[k]){ ok=false; break; }
          rr += dir.dy; cc += dir.dx; k++;
        }
        if(ok){
          // reveal starting cell as hint
          state.cellElems[r][c].classList.add('select');
          setTimeout(()=>state.cellElems[r][c].classList.remove('select'), 1500);
          // penalty: subtract 10 seconds
          state.timer = Math.max(5, state.timer - 10);
          el.timer.textContent = state.timer;
          state.hints--;
          el.hints.textContent = state.hints;
          el.message.textContent = 'Hint used (-10s)';
          return;
        }
      }
    }
  }
  // fallback: show first letter somewhere
  el.message.textContent = 'No hint could be generated (rare).';
}

/* --- Load a level --- */
function loadLevel(index){
  if(index < 0 || index >= LEVELS.length) return;
  state.levelIndex = index;
  const L = LEVELS[index];
  state.size = L.size;
  state.words = L.words.map(s => s.toUpperCase());
  state.grid = null;
  state.foundSet.clear();
  state.score = state.score; // keep cumulative score (or reset if you like)
  state.hints = 3;
  el.hints.textContent = state.hints;

  el.levelNum.textContent = index + 1;
  el.gridSize.textContent = `${L.size}Ã—${L.size}`;
  el.levelSelect.value = index;
  el.btnNext.disabled = true;
  el.message.textContent = `Level ${index+1} â€” find ${state.words.length} words`;
  // timer formula: bigger levels = slightly less time per word to be harder
  const base = Math.max(60, 160 - index*8);
  startTimer(base);

  // place words
  const grid = placeWords(L.size, state.words);
  if(!grid){
    el.message.textContent = 'Failed to layout words â€” retrying...';
    // fallback: reduce complexity by placing fewer words (should be rare)
    setTimeout(()=> loadLevel(index), 300);
    return;
  }
  state.grid = grid;
  fillRandom(state.grid);
  renderGrid(state.grid);
  renderWordList(state.words);
  state.cellElems.flat()?.forEach(e=>e && e.classList.remove('found','select'));
  updateFoundCount();
  updateProgress();
  el.score.textContent = state.score;
  el.totalWords.textContent = state.words.length;
  attachPointerHandlers();
}

/* --- Pointer & selection handling --- */
function attachPointerHandlers(){
  // remove previous listeners
  el.grid.onpointerdown = null;
  window.onpointerup = null;
  window.onpointermove = null;
  // pointer state
  state.dragging = false; state.startCell = null; state.currCell = null;

  // unified pointerdown
  el.grid.onpointerdown = (evt) => {
    evt.preventDefault();
    const point = {x: evt.clientX, y: evt.clientY};
    const cell = document.elementFromPoint(point.x, point.y);
    if(!cell || !cell.classList.contains('cell')) return;
    const r = Number(cell.dataset.r), c = Number(cell.dataset.c);
    state.dragging = true;
    state.startCell = {r,c};
    state.currCell = {r,c};
    clearSelection();
    cell.classList.add('select');
  };

  // pointermove -> highlight current straight path if any (only while dragging)
  window.onpointermove = (evt) => {
    if(!state.dragging) return;
    const point = {x: evt.clientX, y: evt.clientY};
    const target = document.elementFromPoint(point.x, point.y);
    if(!target || !target.classList.contains('cell')) return;
    const r = Number(target.dataset.r), c = Number(target.dataset.c);
    if(state.currCell && state.currCell.r === r && state.currCell.c === c) return;
    state.currCell = {r,c};
    clearSelection();
    const path = getPath(state.startCell.r, state.startCell.c, r, c);
    if(path){
      for(const p of path){
        state.cellElems[p.r][p.c].classList.add('select');
      }
    }
  };

  // pointerup -> finalize selection
  window.onpointerup = (evt) => {
    if(!state.dragging) return;
    state.dragging = false;
    const point = {x: evt.clientX, y: evt.clientY};
    const target = document.elementFromPoint(point.x, point.y);
    let path = null;
    if(target && target.classList.contains('cell')){
      const r = Number(target.dataset.r), c = Number(target.dataset.c);
      path = getPath(state.startCell.r, state.startCell.c, r, c);
    }
    // finalize
    finalizeSelection(path);
    // clear selection UI
    setTimeout(()=>clearSelection(), 200);
    state.startCell = null; state.currCell = null;
  };

  // touch support: handled by pointer events
}

/* --- UI buttons --- */
el.btnRestart.addEventListener('click', () => loadLevel(state.levelIndex));
el.btnNext.addEventListener('click', () => {
  const nxt = Math.min(LEVELS.length - 1, state.levelIndex + 1);
  loadLevel(nxt);
});
el.btnHint.addEventListener('click', () => useHint());

/* --- Init --- */
buildLevelSelect();
loadLevel(0);

/* allow clicking a word in the list to highlight its letters briefly (for UX) */
el.wordList.addEventListener('click', (e) => {
  const li = e.target.closest('.wordItem');
  if(!li) return;
  const w = li.dataset.word;
  // find first occurrence and highlight it shortly
  for(let r=0;r<state.size;r++){
    for(let c=0;c<state.size;c++){
      for(const dir of DIRS){
        let rr=r, cc=c, k=0, ok=true;
        while(k < w.length){
          if(rr<0 || rr>=state.size || cc<0 || cc>=state.size){ ok=false; break; }
          if(state.grid[rr][cc] !== w[k]){ ok=false; break; }
          rr += dir.dy; cc += dir.dx; k++;
        }
        if(ok){
          // highlight
          const path = getPath(r,c, r + dir.dy*(w.length-1), c + dir.dx*(w.length-1));
          if(path){
            path.forEach(p=>state.cellElems[p.r][p.c].classList.add('select'));
            setTimeout(()=>path.forEach(p=>state.cellElems[p.r][p.c].classList.remove('select')), 800);
            return;
          }
        }
      }
    }
  }
});

/* keyboard: N for next, R restart, H hint */
window.addEventListener('keydown', (e)=>{
  if(e.key.toLowerCase() === 'r') loadLevel(state.levelIndex);
  if(e.key.toLowerCase() === 'n') {
    el.btnNext.click();
  }
  if(e.key.toLowerCase() === 'h') el.btnHint.click();
});
</script>
</body>
</html>
